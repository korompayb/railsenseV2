<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Térkép | RailSense</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <meta name="theme-color" content="#1e1e1e">
    <link rel="manifest" href="{{ manifest_url }}" />
    <link rel="icon" href="{{ url_for('static', filename='img/512x512.png') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
         #map {
            width: 100%;
            height: 50vh; /* Kezdetben a térkép a képernyő felét foglalja el */
            transition: height 0.3s ease; /* Animáljuk a méretváltozást */
            border-bottom-right-radius: 30px;
            border-bottom-left-radius: 30px;
        }

        div .leaflet-control-attribution {
            display: none !important;
        }

        .custom-marker {
            background-color: transparent;
            border-radius: 50%;
            border: 2px solid transparent;
        }

        .marker-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
        }

        .custom-marker {
            margin-left: -14px !important;
            margin-top: -10px !important;
            width: 12px;
            height: 12px;
            transform: translate3d(627px, 419px, 0px);
            z-index: 419;
            outline-style: none;
        }

        .notifications {
            position: fixed;
            left: 0;
            width: 100% !important;
        }

        .leaflet-circle {
            stroke: #FF5733;
            /* Kör színe */
            stroke-width: 2px;
            /* Kör vonalának vastagsága */
            fill: rgba(255, 87, 51, 0.3);
            /* Kör belsejének színe és átlátszósága */
        }

        .train-alert.show {
            top: 49rem;
            /* Adjust as needed for the final position */
            opacity: 1;
        }

        .leaflet-control-zoom {
            display: none !important;
            opacity: 0 !important;
        }

        .notifications-container {
            max-height: 50vh; /* Kezdetben az értesítési sáv is a képernyő felét foglalja el */
            overflow-y: auto;
            transition: max-height 0.3s ease; /* Animáljuk a növekedést */
            z-index: 9999;
        }

        @media (max-width: 768px) { /* Az érték módosítható a szükséges képernyőszélesség alapján */
    .notifications-container {
        max-height: 50vh; /* Vagy egy érték, amely biztosítja a görgetést */
        overflow-y: auto;
    }
}

        
.notifications {
  --width: 100%;
  --height: 4.5rem;
  --gap: 1rem;

  position: fixed;
  bottom: 0;
  pointer-events: none;

  

 

.notification.enter {
  transform: translateY(100%) scale(1);
}


  .notification {
    display: flex;
    transform: translateY(var(--y)) scale(var(--scale));
    transform-origin: center;
    transition: all var(--duration) $easing;
    pointer-events: auto;

    &.enter {
      transform: translateY(100%) scale(1);
      // Animate the first notification to slide in from the bottom
      margin-bottom: calc((var(--height) + var(--gap)) * -1);
    }

    &.enter-active {
      transform: translateY(var(--y)) scale(var(--scale));
      margin-bottom: 0;
    }

    &.exit-active {
      transform: translateY(calc(var(--y) - 10%))
        scale(calc(var(--scale) - 0.1));
      margin-bottom: calc((var(--height) + var(--gap)) * -1);

      .notification-inner {
        opacity: 0;
      }
    }
  }

  .notification-inner {
    background-color: var(--bg);
    -webkit-backdrop-filter: blur(0.5rem);
    backdrop-filter: blur(0.5rem);
    padding: 0 1rem;
    border-radius: 0.5rem;
    margin-bottom: var(--gap);
    opacity: var(--opacity);
    transition: all var(--duration) $easing;
    display: flex;
    align-items: center;
    width: 100%;

    h2 {
      font-weight: bold;
      font-size: 0.9rem;
    }

    p {
      margin-top: 0.5rem;
      font-size: 0.8rem;
    }

    .close {
      background: none;
      border: none;
      position: absolute;
      right: 0;
      top: 0;
      font-size: 0.8rem;
      padding: 0.5rem;
      cursor: pointer;
      display: flex;
    }

    .icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 0.3rem;
      margin-right: 1rem;
      font-size: 1rem;
      color: white;

      &.error {
        background-color: #f87171;
      }

      &.success {
        background-color: #10b981;
      }

      &.info {
        background-color: #60a5fa;
      }

      &.warning {
        background-color: #f59e0b;
      }
    }
  }
}

    </style>
</head>

<body>

    <div id="map"></div>
    <!--r style="width: 50%; margin: 0 25% 0 25%; height: 2px; position: absolute; bottom: 12.5rem;"-->
    <div class="leaflet-bottom leaflet-right">
        <div class="leaflet-control-layers leaflet-control" aria-haspopup="true">
            
            <div id="trainAlert" class="notifications">
                <div id="notifications-container" class="notifications-container">
                    
                    <div class="notification enter-done">
                        <!-- Notifications will be appended here -->
                        <div class="notification-inner">
                            <div class="icon warning">
                                <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                                    width="21.543" height="31.123">
                                    <g>
                                        <rect height="31.123" opacity="0" width="21.543" x="0" y="0" />
                                        <path
                                            d="M3.70117 25.8691L17.4902 25.8691C19.9316 25.8691 21.1816 24.2285 21.1816 22.0605L21.1816 13.2617C21.1816 9.7168 20.6934 6.2793 20.1758 4.23828C19.668 2.19727 18.2617 0.712891 16.1426 0.478516C15.2148 0.371094 13.1055 0.205078 10.5957 0.205078C8.07617 0.205078 5.9668 0.371094 5.03906 0.478516C2.91992 0.712891 1.51367 2.19727 1.00586 4.23828C0.488281 6.2793 0 9.7168 0 13.2617L0 22.0605C0 24.2285 1.25 25.8691 3.70117 25.8691ZM7.33398 4.11133C6.89453 4.11133 6.62109 3.82812 6.62109 3.39844C6.62109 2.97852 6.89453 2.69531 7.33398 2.69531L13.8574 2.69531C14.2871 2.69531 14.5605 2.97852 14.5605 3.39844C14.5605 3.82812 14.2871 4.11133 13.8574 4.11133ZM10.5957 17.6855C7.75391 17.666 5.21484 17.5488 3.79883 17.3828C3.00781 17.2949 2.66602 16.7871 2.66602 16.0449L2.66602 13.0762C2.66602 10.6348 2.92969 8.59375 3.16406 7.53906C3.29102 6.94336 3.65234 6.52344 4.22852 6.45508C5.67383 6.28906 7.45117 6.19141 10.5957 6.18164C13.7207 6.17188 15.498 6.28906 16.8848 6.44531C17.5 6.52344 17.8809 6.94336 18.0176 7.53906C18.2422 8.59375 18.5059 10.6348 18.5059 13.0762L18.5059 16.0449C18.5059 16.7969 18.1641 17.3047 17.373 17.3828C15.4395 17.5879 12.8906 17.6855 10.5957 17.6855ZM4.72656 23.1738C3.76953 23.1738 3.06641 22.4707 3.06641 21.5039C3.06641 20.5469 3.76953 19.8438 4.72656 19.8438C5.69336 19.8438 6.39648 20.5469 6.39648 21.5039C6.39648 22.4707 5.67383 23.1738 4.72656 23.1738ZM16.4551 23.1836C15.498 23.1836 14.7754 22.4609 14.7754 21.5039C14.7754 20.5566 15.498 19.834 16.4551 19.834C17.4023 19.834 18.125 20.5566 18.125 21.5039C18.125 22.4609 17.3926 23.1836 16.4551 23.1836ZM1.94336 31.123L2.59766 31.123C2.91992 31.123 3.0957 31.0254 3.27148 30.752L6.68945 25.2441L4.51172 25.2441L1.45508 30.1562C1.15234 30.625 1.41602 31.123 1.94336 31.123ZM3.10547 29.5898L18.0957 29.5898L18.0957 27.8613L3.10547 27.8613ZM18.623 31.123L19.2773 31.123C19.8047 31.123 20.0293 30.6152 19.7461 30.1562L16.709 25.2441L14.5312 25.2441L17.9492 30.752C18.1152 31.0254 18.291 31.123 18.623 31.123Z"
                                            fill="#ffffff" fill-opacity="0.85" />
                                    </g>
                                </svg>
                            </div>
                    
        
                            <div style="padding-top: 10px;">
                                <h2>Vigyázat!</h2>
                                <p id="time" class="close">Ma 1:10</p>
                                <p>Vonat van a közelben, óvatosan az átkeléssel!</p>
        
                            </div>
                        
                    </div>
                </div>
                </div>
                

                    
                </div>

            </div>

        </div>
    </div>

    <div class="leaflet-top leaflet-right" style="padding: 1%; color: #000;">
        <h6>RailSense v3.2 - Dynamic Map Update</h6>
        <h6 style="text-align: right;">BETA</h6>
    </div>
    <div class="leaflet-top leaflet-left" style="left: 5rem !important;">
        <div class="leaflet-control-layers leaflet-control" aria-haspopup="true">
            <a class="btn text-50 btn-outline-dark search-button position-absolute end-0 m-2"
                style="z-index: 1;" href="{{ url_for('search') }}">
                Vissza
            </a>
        </div>
    </div>
    <div class="leaflet-bottom leaflet-left" style="left: 5rem !important; bottom: -10rem !important;">
        <br>


    </div>
    <script>
       document.addEventListener('DOMContentLoaded', function() {
    var notificationContainer = document.getElementById('notifications-container');
    var mapElement = document.getElementById('map');

    var initialMapHeight = 50; // Térkép kezdő magassága (vh)
    var minMapHeight = 20; // Térkép minimális magassága (vh)
    var initialNotificationHeight = 20; // Értesítési konténer alapértelmezett magassága (vh)
    var maxNotificationHeight = 70; // Értesítési konténer maximális magassága (vh)

    function updateLayout() {
        var scrollTop = notificationContainer.scrollTop;
        var scrollHeight = notificationContainer.scrollHeight - notificationContainer.clientHeight;

        var scrollRatio = scrollTop / scrollHeight;

        var newMapHeight = initialMapHeight - (scrollRatio * (initialMapHeight - minMapHeight));
        mapElement.style.height = Math.max(newMapHeight, minMapHeight) + 'vh';

        var newNotificationHeight = initialNotificationHeight + (scrollRatio * (maxNotificationHeight - initialNotificationHeight));
        notificationContainer.style.maxHeight = Math.max(newNotificationHeight, initialNotificationHeight) + 'vh';
    }

    // Update layout on scroll inside the notifications container
    notificationContainer.addEventListener('scroll', updateLayout);

    // Initial layout update
    updateLayout();
});


    </script>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        

        function updateTime() {
            // Calculate the time elapsed since the notification was displayed
            const now = new Date();
            const elapsed = Math.floor((now - startTime) / 60000); // Elapsed time in minutes

            // Determine the appropriate display text
            let displayText;
            if (elapsed === 0) {
                displayText = 'most';
            } else if (elapsed === 1) {
                displayText = '1 perce';
            } else {
                displayText = `${elapsed} perce`;
            }

            // Update the time display
            document.getElementById('time').textContent = displayText;
        }

        // Set the start time when the page loads
        const startTime = new Date();

        // Update the time when the page loads
        updateTime();

        // Update the time every minute (60000 milliseconds)
        setInterval(updateTime, 60000);
    </script>
    <script>
        const latitude = {{ lat }};
        const longitude = {{ lon }};

        var map = L.map('map').setView([latitude, longitude], 13);
        var jawgLayer = L.tileLayer('https://tile.jawg.io/jawg-sunny/{z}/{x}/{y}{r}.png?access-token={accessToken}', {
            attribution: '<a href="https://jawg.io" title="Tiles Courtesy of Jawg Maps" target="_blank">&copy; <b>Jawg</b>Maps</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            minZoom: 0,
            maxZoom: 22,
            accessToken: 'iGR4cAeILxmIyHrzUkdz1fKcfoWHenxaQdGtzAO6ZDkC6vGJ8SwVuT8Kyh7Mf8af'
        });

        jawgLayer.addTo(map);

        var stopsLayerGroup = L.layerGroup().addTo(map); // LayerGroup létrehozása a járművek tárolására
        var userMarker = L.marker([latitude, longitude], { icon: L.icon({ iconUrl: 'https://svgshare.com/i/18yA.svg', iconSize: [25, 41] }) }).addTo(map);



        

        // Függvény a térkép középpontjának frissítésére és járművek újra lekérésére
        function updateVehicles() {
    var center = map.getCenter(); // Aktuális térkép középpontja
    var lat = center.lat.toFixed(7); // Latitúdó 7 tizedesjegyig kerekítve
    var lon = center.lng.toFixed(7); // Hosszúság 7 tizedesjegyig kerekítve
    var radius = 10000; // Sugár: 10000 méter

    const selectedVehicleTypes = ["RAIL"]; // Alapértelmezett filter

    var apiUrl = `https://futar.bkk.hu/api/query/v1/ws/otp/api/where/vehicles-for-location?clientLon=${lon}&clientLat=${lat}&onlyDepartures=false&limit=60&lat=${lat}&lon=${lon}&radius=${radius}&minResult=1&appVersion=1.1.abc&version=2&includeReferences=true&minutesAfter=60&key=7ff7c954-05d3-4dd2-93b6-cb714dcdca69`;

    fetch(apiUrl)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            stopsLayerGroup.clearLayers();
            if (data.data && data.data.list && data.data.references) {
                var vehicles = data.data.list;
                var stops = data.data.references.stops;
                var routes = data.data.references.routes;

                var trainNearby = false;

                vehicles.forEach(function (vehicle) {
                    if (selectedVehicleTypes.includes(vehicle.vehicleRouteType)) {
                        var direction = vehicle.bearing || 0;
                        
                        var route = routes[vehicle.routeId];
                        var color = route ? route.color : defaultColor;
                        var textColor = route ? route.textColor : 'FFFFFF'; // Alapértelmezett szöveg szín fehér
                        var shortName = route ? route.shortName : 'N/A'; // Alapértelmezett név
                        var description = route ? route.description : 'N/A'; // Alapértelmezett leírás

                        // A vonat megjelenítése a térképen
                        var marker = L.marker([vehicle.location.lat, vehicle.location.lon], {
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `<svg width="25" height="35" fill="none" xmlns="http://www.w3.org/2000/svg" style="transform: rotate(${direction}deg);">
                            <path d="M23.9395 18.7344C23.9395 24.8689 18.8493 29.959 12.7148 29.959C6.5909 29.959 1.5 24.8696 1.5 18.7344C1.5 12.6082 6.58187 7.51953 12.7051 7.51953C18.8418 7.51953 23.9395 12.6119 23.9395 18.7344Z" fill="white" stroke="#${routes[vehicle.routeId].color }" stroke-width="3"/>
                            <path d="M21 6L15 4.875L13 4.5L11 4.875L5 6L13 0L21 6Z" fill="black"/>
                            </svg>`
                            })
                        }).addTo(stopsLayerGroup)
                            .bindPopup(`<h6>
                            <div class="viszonylatdoboz d-flex justify-content-center align-items-center"
                            style="padding: 5px; border-radius: 5px; background-color:#${routes[vehicle.routeId].color}!important; width: 50px; height: 30px;">
                            <span style="font-weight: bold; color: #${routes[vehicle.routeId].textColor};">${routes[vehicle.routeId].shortName}</span>
                            </div>${routes[vehicle.routeId].description}</h6>
                            <strong>${vehicle.status === 'IN_TRANSIT_TO' ? stops[vehicle.stopId].name + ' felé közeledik' : vehicle.status === 'STOPPED_AT' ? stops[vehicle.stopId].name + ' megállóhelyen áll' : vehicle.status}</strong><br>
                            <em>${vehicle.label}</em><br>`)
                            .on('click', function () {
                                fetchTripDetails(vehicle.tripId, this);
                            });

                        // Ellenőrizzük, hogy a vonat 2 km-es körön belül van-e
                        if (isTrainWithinRadius(vehicle.location.lat, vehicle.location.lon, latitude, longitude, 2)) {
                            trainNearby = true;
                        }

                        createNotification(vehicle, routes, stops); // Átadjuk a routes és stops adatokat is
                    }
                });

                var alertElement = document.getElementById('trainAlert');
                if (trainNearby) {
                    alertElement.classList.add('show');
                } else {
                    alertElement.classList.remove('show');
                }

            } else {
                throw new Error('Vehicles data not found in API response');
            }
        })
        .catch(error => console.error('Error fetching vehicles:', error));
}



        function createNotification(vehicle, routes, stops) {
    const notificationContainer = document.getElementById('notifications-container');
    
    // Ellenőrizzük, hogy a szükséges paraméterek érvényesek
    if (!routes || !stops) {
        console.error('Routes vagy stops adatok nem érhetők el.');
        return;
    }

    // Ellenőrizzük, hogy a routeId és stopId léteznek
    const route = routes ? routes[vehicle.routeId] : null;
    const stop = stops ? stops[vehicle.stopId] : null;

    // Hozz létre egy értesítést, ha a route és a stop érvényes
    if (route && stop) {
        const notification = document.createElement('div');
        notification.className = 'notification enter-done';

        notification.innerHTML = `
            <div class="notification-inner">
                <div class="icon warning" style="background-color:#${routes[vehicle.routeId].color}!important; color: #${routes[vehicle.routeId].textColor};">
                    <h2 style="text-align:center;">${route.shortName}</h2>
                    
                </div>
                <div style="padding-top: 10px;">
                    
                    <h2>${route.description}</h2>
                    <!--strong>${vehicle.status === 'IN_TRANSIT_TO' ? `Halad` : vehicle.status === 'STOPPED_AT' ? `Áll` : vehicle.status}</strong-->
                    <p class="close">${vehicle.status === 'IN_TRANSIT_TO' ? `Halad` : vehicle.status === 'STOPPED_AT' ? `Áll` : vehicle.status}</p>
                    <p>${vehicle.label}</p>
                </div>
            </div>
        `;

        notificationContainer.appendChild(notification);
    } else {
        console.error('Nem található route vagy stop az adatokban.');
    }
}




        // Függvény a távolság számításához (Haversine formula alapján)
        function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
            const R = 6371; // A Föld sugara km-ben
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = R * c;
            return distance;
        }

        function deg2rad(deg) {
            return deg * (Math.PI / 180);
        }

        // Függvény annak ellenőrzésére, hogy a vonat 2 km-en belül van-e
        function isTrainWithinRadius(trainLat, trainLon, userLat, userLon, radiusInKm) {
            const distance = getDistanceFromLatLonInKm(trainLat, trainLon, userLat, userLon);
            return distance <= radiusInKm;
        }

        // Geolocation API to get the user's current position
        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(showPosition, handleError, {
                    enableHighAccuracy: true
                });
            } else {
                alert("Geolocation is not supported by this browser.");
            }
        }

        function showPosition(position) {
            var lat = position.coords.latitude;
            var lon = position.coords.longitude;
            map.setView([lat, lon], 13); // Center the map on the user's location
            userMarker.setLatLng([lat, lon]); // Update marker position

            // Reverse geocode to get the address
            fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`)
                .then(response => response.json())
                .then(data => {
                    var address = data.display_name;
                    userMarker.bindPopup(`Your current location: ${address}`);
                })
                .catch(error => console.error('Error fetching address:', error));
        }

        function handleError(error) {
            switch (error.code) {
                case error.PERMISSION_DENIED:
                    alert("Nem kaptam engedélyt a GPS adataidhoz :(");
                    break;
                case error.POSITION_UNAVAILABLE:
                    alert("Location information is unavailable.");
                    break;
                case error.TIMEOUT:
                    alert("The request to get user location timed out.");
                    break;
                case error.UNKNOWN_ERROR:
                    alert("An unknown error occurred.");
                    break;
            }
        }
        let longPressTimer;
        const longPressThreshold = 500; // Time in milliseconds



        function startLongPressTimer(e, latlng) {
            pressStart = Date.now();
            longPressTimer = setTimeout(function () {
                onLongPress(latlng);
            }, longPressThreshold);
        }

        function clearLongPressTimer() {
            clearTimeout(longPressTimer);
        }

        map.on('mousedown', function (e) {
            startLongPressTimer(e, e.latlng);
        });
        map.on('mouseup', clearLongPressTimer);
        map.on('mouseout', clearLongPressTimer);

        map.on('touchstart', function (e) {
            if (e.touches.length === 1) {
                var latlng = map.mouseEventToLatLng(e.touches[0]);
                startLongPressTimer(e, latlng);
            }
        });
        map.on('touchend', clearLongPressTimer);
        map.on('touchcancel', clearLongPressTimer);

        map.on('moveend', function () {
            updateVehicles();
        });

        updateVehicles();
        setInterval(updateVehicles, 10000);

        // Get the user's current location when the map loads
        getCurrentLocation();
    </script>



</body>

</html>